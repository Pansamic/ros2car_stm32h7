/**
 * @file drv8874.c
 * @author Pansamic (pansamic@foxmail.com)
 * @brief Driver code for Texas Instrument DRV8874 DC motor driver.
 * @version 0.1
 * @date 2025-03-19
 * 
 * @copyright Copyright (c) 2025
 * 
 */
#include <string.h>
#include <stdlib.h>
#include "FreeRTOS.h"
#include "task.h"
#include "timers.h"
#include "FreeRTOS_CLI.h"
#include "lwprintf.h"
#include "drv8874.h"

#ifdef cplusplus
extern "C" {
#endif

#define DRV8874_CURRENT_FACTOR 450

static BaseType_t drv8874_control_command(char * write_buffer, size_t write_buffer_len, const char * command_string);

/* FreeRTOS CLI definition for DRV8874 command application. */
static const CLI_Command_Definition_t drv8874_control_command_def =
{
    ( const char * const ) "drv8874", /* The command string to type. */
    ( const char * const ) "drv8874 <ID> <mode> <target value>:\r\nSet DRV8874 motor control mode and parameters.\r\n\r\n",
    drv8874_control_command, /* The function to run. */
    -1 /* No parameters are expected. */
};

/* DRV8874 control block instance */
drv8874_t motors[DRV8874_MOTOR_AMOUNT];

uint32_t drv8874_timer_count = 0;

/* This is a buffer used to store the voltage value 
 * generated by the ADC module converting the current source 
 * inside the DRV8874 chip through the external resistance. */
int16_t drv8874_adc[DRV8874_MOTOR_AMOUNT] = {0};

/* FreeRTOS timer handles for motor control loop timer */
static xTimerHandle motor_torque_control_timer;
static xTimerHandle motor_velocity_control_timer;
static xTimerHandle motor_position_control_timer;


/**
 * @brief Initialize ADC for periodic conversion and DMA auto transfer.
 * 
 * @return drv8874_err_t DRV8874_OK on success, DRV8874_ERROR on failure.
 */
static drv8874_err_t drv8874_init_adc(void)
{    
    /* Run ADC self calibration */
    // Need to define which calib parameter has to be used
    LL_ADC_StartCalibration(ADC1, LL_ADC_CALIB_OFFSET, LL_ADC_SINGLE_ENDED);
    LL_ADC_StartCalibration(ADC1, LL_ADC_CALIB_OFFSET_LINEARITY, LL_ADC_SINGLE_ENDED);

    while (LL_ADC_IsCalibrationOnGoing(ADC1) != 0);
    
    /* Delay between ADC end of calibration and ADC enable. */
    vTaskDelay(pdMS_TO_TICKS(5));
    
    /* Enable ADC */
    LL_ADC_Enable(ADC1);

    while (LL_ADC_IsActiveFlag_ADRDY(ADC1) == 0);

    if ((LL_ADC_IsEnabled(ADC1) == 1)               &&
        (LL_ADC_IsDisableOngoing(ADC1) == 0)        &&
        (LL_ADC_REG_IsConversionOngoing(ADC1) == 0)   )
    {
        LL_ADC_REG_StartConversion(ADC1);
        LL_DMA_SetPeriphAddress(DMA2, LL_DMA_STREAM_2, LL_ADC_DMA_GetRegAddr(ADC1, LL_ADC_DMA_REG_REGULAR_DATA_MULTI));
        LL_DMA_SetMemoryAddress(DMA2, LL_DMA_STREAM_2, (uint32_t)drv8874_adc);
        LL_DMA_SetDataLength(DMA2, LL_DMA_STREAM_2, DRV8874_MOTOR_AMOUNT);
        LL_DMA_EnableStream(DMA2, LL_DMA_STREAM_2);
    }
    else
    {
        DRV8874_LOG_ERROR("DRV8874 init failed: ADC conversion start could not be performed.\n");
        return DRV8874_ERROR;
    }

    return DRV8874_OK;
}
/**
 * @brief Get the current time.
 * @note Returned value is specifically for velocity calculation with encoder.
 * @return drv8874_float_t unit: seconds
 */
drv8874_float_t drv8874_get_time(void)
{
    /* This frequency is timer clock frequency / clock division / prescaler */
    static const drv8874_float_t timer_frequency = 1000000.0;
    return ((drv8874_float_t)drv8874_timer_count + (drv8874_float_t)LL_TIM_GetCounter(ENC_TIME_TIM))/timer_frequency;
}

void drv8874_get_feedback(drv8874_t *dev)
{
    if(dev->encoder_timer == LPTIM1 || dev->encoder_timer == LPTIM2 || dev->encoder_timer == LPTIM3 || dev->encoder_timer == LPTIM4)
    {
        if (dev->reverse_encoder)
        {
            dev->encoder_count -= (int16_t)LL_LPTIM_GetCounter((LPTIM_TypeDef*)dev->encoder_timer);
        }
        else
        {
            dev->encoder_count += (int16_t)LL_LPTIM_GetCounter((LPTIM_TypeDef*)dev->encoder_timer);
        }
        LL_LPTIM_ResetCounter((LPTIM_TypeDef*)dev->encoder_timer);
    }
    else
    {
        if (dev->reverse_encoder)
        {
            dev->encoder_count -= (int16_t)LL_TIM_GetCounter((TIM_TypeDef*)dev->encoder_timer);
        }
        else
        {
            dev->encoder_count += (int16_t)LL_TIM_GetCounter((TIM_TypeDef*)dev->encoder_timer);
        }
        LL_TIM_SetCounter((TIM_TypeDef*)dev->encoder_timer, 0);
    }
    dev->current_position = (drv8874_float_t)dev->encoder_count / (dev->encoder_round_count * dev->turndown_ratio) * 2 * 3.14159265f;

    DRV8874_LOG_TRACE("DRV8874 motor %u encoder count %d\n", dev->id, dev->encoder_count);

    DRV8874_LOG_DEBUG("DRV8874 motor %u current position %f rad.\n", dev->id, dev->current_position);

    drv8874_float_t update_interval = drv8874_get_time() - dev->last_update_time;

    dev->last_update_time = drv8874_get_time();

    DRV8874_LOG_TRACE("DRV8874 motor %u update interval = %f.\n", dev->id, update_interval);

    /* Calculate angular velocity */
    dev->current_velocity = 2 * 3.14159265f * 
        (drv8874_float_t)(dev->encoder_count - dev->previous_encoder_count) /
        (drv8874_float_t)(dev->encoder_round_count*dev->turndown_ratio) / (update_interval);

    DRV8874_LOG_DEBUG("DRV8874 motor %u current velocity %f rad/s.\n", dev->id, dev->current_velocity);

    dev->previous_encoder_count = dev->encoder_count;

    /* Here are 2 equations from DRV8874 datasheet to calculate H bridge current inside the chip. */
    /* Equation 1: I_{PROPI} (μA) = (I_{LS1} + I_{LS2}) (A) x A_{IPROPI} (μA/A) */
    /* Equation 2: V_{IPROPI} (V) = I_{PROPI} (A) x R_{IPROPI} (Ω) */
    dev->current_torque = (drv8874_float_t)drv8874_adc[dev->id-1] / (drv8874_float_t)dev->ext_resistor * 1000.0 / DRV8874_CURRENT_FACTOR / 2 * dev->torque_coefficient;
    // DRV8874_LOG_INFO("DRV8874 motor %u current torque %f Nm.\n", dev->id, dev->current_torque);
    DRV8874_LOG_INFO("DRV8874 motor %u adc value %d.\n", dev->id, drv8874_adc[dev->id-1]);
}
/**
 * @brief Update position control logic for the motor.
 * 
 * @param dev Pointer to the DRV8874 motor instance.
 * @return drv8874_err_t DRV8874_OK on success, DRV8874_ERROR on failure.
 */
static drv8874_err_t drv8874_position_control(drv8874_t *dev)
{
    /* Calculate angular position error */
    dev->error_pos = dev->target_position - dev->current_position;
    DRV8874_LOG_TRACE("DRV8874 position control: motor %u position error %f.\n", dev->id, dev->error_pos);

    /* Update integral error */
    dev->integral_error_pos += dev->error_pos;
    DRV8874_LOG_TRACE("DRV8874 position control: motor %u integral position error %f.\n", dev->id, dev->integral_error_pos);

    /* Apply PI control logic */
    dev->control_pos = (dev->kp_pos * dev->error_pos
        // + dev->ki_pos * dev->integral_error_pos
        + dev->kd_pos * (dev->error_pos - dev->prev_error_pos)
    );
    DRV8874_LOG_TRACE("DRV8874 position control: motor %u control position %f.\n", dev->id, dev->control_pos);

    /* Update previous error with current error for next control update */
    dev->prev_error_pos = dev->error_pos;

    return DRV8874_OK;
}
/**
 * @brief Update velocity control logic for the motor.
 * 
 * @param dev Pointer to the DRV8874 motor instance.
 * @return drv8874_err_t DRV8874_OK on success, DRV8874_ERROR on failure.
 */
static drv8874_err_t drv8874_velocity_control(drv8874_t *dev)
{
    if (dev->mode != DRV8874_MODE_VELOCITY)
    {
        dev->target_velocity = dev->control_pos;
    }
    /* Calculate angular velocity error */
    dev->error_vel = dev->target_velocity - dev->current_velocity;
    DRV8874_LOG_TRACE("DRV8874 velocity control: motor %u velocity error %f.\n", dev->id, dev->error_vel);

    /* Update integral error */
    dev->integral_error_vel += dev->error_vel;
    DRV8874_LOG_TRACE("DRV8874 velocity control: motor %u integral velocity error %f.\n", dev->id, dev->integral_error_vel);

    /* Apply PI control logic */
    dev->control_vel = (dev->kp_vel * dev->error_vel
        + dev->ki_vel * dev->integral_error_vel
        // + dev->kd_vel * (dev->error_vel - dev->prev_error_vel)
    );
    DRV8874_LOG_TRACE("DRV8874 velocity control: motor %u control velocity %f.\n", dev->id, dev->control_vel);

    /* Update previous error with current error for next control update */
    dev->prev_error_vel = dev->error_vel;

    return DRV8874_OK;
}
/**
 * @brief Update torque control logic for the motor.
 * 
 * @param dev Pointer to the DRV8874 motor instance.
 * @return drv8874_err_t DRV8874_OK on success, DRV8874_ERROR on failure.
 */
drv8874_err_t drv8874_torque_control(drv8874_t *dev)
{
    /* Output compare value to be written into PWM timer channel */
    uint32_t oc_value = 0;

    drv8874_get_feedback(dev);

    /* Calculate torque error */
    if (dev->mode != DRV8874_MODE_TORQUE)
    {
        dev->target_torque = dev->control_vel;
    }

    dev->error_torq = dev->target_torque - dev->current_torque;
    DRV8874_LOG_TRACE("DRV8874 torque control: motor %u torque error %f.\n", dev->id, dev->error_torq);

    /* Update integral error */
    dev->integral_error_torq += dev->error_torq;
    DRV8874_LOG_TRACE("DRV8874 torque control: motor %u integral torque error %f.\n", dev->id, dev->integral_error_torq);

    /* Apply PI control logic */
    dev->control_torq = (dev->kp_torq * dev->error_torq
        + dev->ki_torq * dev->integral_error_torq
        // + dev->kd_torq * (dev->error_torq - dev->prev_error_torq)
    );
    DRV8874_LOG_TRACE("DRV8874 torque control: motor %u control torque %f.\n", dev->id, dev->control_torq);

    /* Update previous error with current error for next control update */
    dev->prev_error_torq = dev->error_torq;

    /* If sudden rotation direction reverse is needed, brake until motor velocity decrease to 0.1 rad/s
     * and then apply the reverse velocity to motor to avoid damage of H bridge inside the DRV8874 */
    // if((dev->target_velocity * dev->current_velocity < 0) && (dev->current_velocity > 0.1 || dev->current_velocity < -0.1))
    // {
    //     drv8874_brake(dev);
    //     DRV8874_LOG_TRACE("DRV8874 velocity control: motor %u brake to stop motor.\n", dev->id);
    //     return DRV8874_OK;
    // }
    // else
    // {
        if((dev->control_torq < 0 && !dev->reverse) || (dev->control_torq > 0 && dev->reverse))
        {
            drv8874_set_direction(dev, DRV8874_DIRECTION_BACKWARD);
        }
        else if((dev->control_torq > 0 && !dev->reverse) || (dev->control_torq < 0 && dev->reverse))
        {
            drv8874_set_direction(dev, DRV8874_DIRECTION_FORWARD);
        }
    // }

    /* Output compare value is the sum of feed forward value and feed back value. */
    oc_value = (uint32_t)((drv8874_float_t)dev->pwm_tim_autoreload * dev->control_vel / dev->max_velocity);
    DRV8874_LOG_TRACE("DRV8874 velocity control: motor %u raw output compare value %d.\n", dev->id, oc_value);

    /* Constrain the value of output comapre register */
    oc_value = oc_value > dev->pwm_tim_autoreload ? dev->pwm_tim_autoreload : oc_value;
    DRV8874_LOG_TRACE("DRV8874 velocity control: motor %u constrained output compare value %d.\n", dev->id, oc_value);

    switch(dev->pwm_channel)
    {
        case LL_TIM_CHANNEL_CH1:
            LL_TIM_OC_SetCompareCH1(dev->pwm_timer, oc_value);
            break;
        case LL_TIM_CHANNEL_CH2:
            LL_TIM_OC_SetCompareCH2(dev->pwm_timer, oc_value);
            break;
        case LL_TIM_CHANNEL_CH3:
            LL_TIM_OC_SetCompareCH3(dev->pwm_timer, oc_value);
            break;
        case LL_TIM_CHANNEL_CH4:
            LL_TIM_OC_SetCompareCH4(dev->pwm_timer, oc_value);
            break;
        default:
            DRV8874_LOG_ERROR("DRV8874 error: motor %u unknown pwm channel %d.\n", dev->id, dev->pwm_channel);
            return DRV8874_ERROR;
    }

    return DRV8874_OK;
}
static void drv8874_position_controller(TimerHandle_t xTimer)
{
    if (xTimer == motor_position_control_timer)
    {
        if (motors[0].enable)
            drv8874_position_control(&motors[0]);
        if (motors[1].enable)
            drv8874_position_control(&motors[1]);
        if (motors[2].enable)
            drv8874_position_control(&motors[2]);
        if (motors[3].enable)
            drv8874_position_control(&motors[3]);
    }
}
static void drv8874_velocity_controller(TimerHandle_t xTimer)
{
    if (xTimer == motor_velocity_control_timer)
    {
        if (motors[0].enable)
            drv8874_velocity_control(&motors[0]);
        if (motors[1].enable)
            drv8874_velocity_control(&motors[1]);
        if (motors[2].enable)
            drv8874_velocity_control(&motors[2]);
        if (motors[3].enable)
            drv8874_velocity_control(&motors[3]);
    }
}
static void drv8874_torque_controller(TimerHandle_t xTimer)
{
    if (xTimer == motor_torque_control_timer)
    {
        if (motors[0].enable)
            drv8874_torque_control(&motors[0]);
        if (motors[1].enable)
            drv8874_torque_control(&motors[1]);
        if (motors[2].enable)
            drv8874_torque_control(&motors[2]);
        if (motors[3].enable)
            drv8874_torque_control(&motors[3]);
    }
}
/**
 * @brief FreeRTOS CLI command handler for controlling DRV8874 motors.
 * 
 * @param write_buffer Buffer to write the command response.
 * @param write_buffer_len Length of the write buffer.
 * @param command_string The command string entered by the user.
 * @return BaseType_t pdTRUE if the command was successfully processed, pdFALSE otherwise.
 */
BaseType_t drv8874_control_command(char * write_buffer, size_t write_buffer_len, const char * command_string)
{
    char *parameter_string;
    BaseType_t parameter_string_length;
    char subcommand[16];
    char mode[16];
    drv8874_float_t target_value;
    drv8874_t *motor = &motors[0]; // Assuming single motor for simplicity

    // Parse subcommand ("mode" or "param")
    parameter_string = (char *) FreeRTOS_CLIGetParameter(command_string, 1, &parameter_string_length);
    if (parameter_string == NULL)
    {
        write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Missing subcommand.\r\n");
        return pdFALSE;
    }
    strncpy(subcommand, (const char *) parameter_string, parameter_string_length);
    subcommand[parameter_string_length] = '\0';

    if (strcmp(subcommand, "mode") == 0)
    {
        // Parse mode
        parameter_string = (char *) FreeRTOS_CLIGetParameter(command_string, 2, &parameter_string_length);
        if (parameter_string == NULL)
        {
            write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Missing mode.\r\n");
            return pdFALSE;
        }
        strncpy(mode, (const char *) parameter_string, parameter_string_length);
        mode[parameter_string_length] = '\0';

        // Parse target value
        parameter_string = (char *) FreeRTOS_CLIGetParameter(command_string, 3, &parameter_string_length);
        if (parameter_string == NULL)
        {
            write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Missing target value.\r\n");
            return pdFALSE;
        }
        target_value = atof((const char *) parameter_string);

        // Set mode and target value
        if (strcmp(mode, "pos") == 0 || strcmp(mode, "position") == 0)
        {
            drv8874_set_position_mode(motor);
            drv8874_set_position(motor, target_value);
        }
        else if (strcmp(mode, "vel") == 0 || strcmp(mode, "velocity") == 0)
        {
            drv8874_set_velocity_mode(motor);
            drv8874_set_velocity(motor, target_value);
        }
        else if (strcmp(mode, "torq") == 0 || strcmp(mode, "torque") == 0)
        {
            drv8874_set_torque_mode(motor);
            drv8874_set_torque(motor, target_value);
        }
        else
        {
            write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Invalid mode. Use 'pos', 'vel', or 'torq'.\r\n");
            return pdFALSE;
        }
    }
    else if (strcmp(subcommand, "param") == 0)
    {
        // Parse mode
        parameter_string = (char *) FreeRTOS_CLIGetParameter(command_string, 2, &parameter_string_length);
        if (parameter_string == NULL)
        {
            write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Missing mode.\r\n");
            return pdFALSE;
        }
        strncpy(mode, (const char *) parameter_string, parameter_string_length);
        mode[parameter_string_length] = '\0';

        // Validate mode
        int requires_kp = 0, requires_ki = 0, requires_kd = 0;
        if (strcmp(mode, "pos") == 0 || strcmp(mode, "position") == 0)
        {
            requires_kp = 1;
            requires_kd = 1;
        }
        else if (strcmp(mode, "vel") == 0 || strcmp(mode, "velocity") == 0)
        {
            requires_kp = 1;
            requires_ki = 1;
        }
        else if (strcmp(mode, "torq") == 0 || strcmp(mode, "torque") == 0)
        {
            requires_kp = 1;
            requires_ki = 1;
        }
        else
        {
            write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Invalid mode. Use 'pos', 'vel', or 'torq'.\r\n");
            return pdFALSE;
        }

        // Parse parameters
        int param_count = 3; // Start after "param <mode>"
        while ((parameter_string = (char *) FreeRTOS_CLIGetParameter(command_string, param_count, &parameter_string_length)) != NULL)
        {
            char param_name[16];
            drv8874_float_t param_value;

            strncpy(param_name, (const char *) parameter_string, parameter_string_length);
            param_name[parameter_string_length] = '\0';

            // Parse value
            param_count++;
            parameter_string = (char *) FreeRTOS_CLIGetParameter(command_string, param_count, &parameter_string_length);
            if (parameter_string == NULL)
            {
                write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Missing value for parameter '%s'.\r\n", param_name);
                return pdFALSE;
            }
            param_value = atof((const char *) parameter_string);

            // Set parameter
            if (strcmp(param_name, "kp") == 0)
            {
                if (!requires_kp)
                {
                    write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: 'kp' not required for mode '%s'.\r\n", mode);
                    return pdFALSE;
                }
                if (strcmp(mode, "pos") == 0 || strcmp(mode, "position") == 0)
                    motor->kp_pos = param_value;
                else if (strcmp(mode, "vel") == 0 || strcmp(mode, "velocity") == 0)
                    motor->kp_vel = param_value;
                else if (strcmp(mode, "torq") == 0 || strcmp(mode, "torque") == 0)
                    motor->kp_torq = param_value;
            }
            else if (strcmp(param_name, "ki") == 0)
            {
                if (!requires_ki)
                {
                    write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: 'ki' not required for mode '%s'.\r\n", mode);
                    return pdFALSE;
                }
                if (strcmp(mode, "vel") == 0 || strcmp(mode, "velocity") == 0)
                    motor->ki_vel = param_value;
                else if (strcmp(mode, "torq") == 0 || strcmp(mode, "torque") == 0)
                    motor->ki_torq = param_value;
            }
            else if (strcmp(param_name, "kd") == 0)
            {
                if (!requires_kd)
                {
                    write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: 'kd' not required for mode '%s'.\r\n", mode);
                    return pdFALSE;
                }
                if (strcmp(mode, "pos") == 0 || strcmp(mode, "position") == 0)
                    motor->kd_pos = param_value;
            }
            else
            {
                write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Unknown parameter '%s'.\r\n", param_name);
                return pdFALSE;
            }

            param_count++;
        }
    }
    else
    {
        write_buffer_len -= lwsnprintf(write_buffer, write_buffer_len, "Error: Invalid subcommand. Use 'mode' or 'param'.\r\n");
        return pdFALSE;
    }

    return pdTRUE;
}

drv8874_err_t drv8874_init()
{
    drv8874_err_t err = DRV8874_OK;

    memset(motors, 0, sizeof(motors));

    motors[0].id = 1;
    motors[0].mode = DRV8874_MODE_VELOCITY;
    motors[0].reverse = 0;
    motors[0].reverse_encoder = 0;
    motors[0].ctrl_gpio_port = CTRL_MOTOR1_GPIO_Port;
    motors[0].ctrl_gpio_pin = CTRL_MOTOR1_Pin;
    motors[0].pwm_timer = MOTOR_PWM_TIM;
    motors[0].pwm_channel = LL_TIM_CHANNEL_CH1;
    motors[0].pwm_tim_autoreload = LL_TIM_GetAutoReload(MOTOR_PWM_TIM);
    motors[0].encoder_timer = MOTOR1_ENC_TIM;
    motors[0].encoder_round_count = 13*4;
    motors[0].torque_coefficient = 0.3f; // A inaccurate approximation
    motors[0].turndown_ratio = 30;
    motors[0].max_velocity = 6*2*3.1415926;
    motors[0].ext_resistor = 1500; // From schematic of this board.
    motors[0].kp_pos = 5;
    motors[0].kd_pos = 0.1;
    motors[0].kp_vel = 5;
    motors[0].ki_vel = 0.1;
    motors[0].kp_torq = 5;
    motors[0].ki_torq = 0.1;

    motors[1].id = 2;
    motors[1].mode = DRV8874_MODE_VELOCITY;
    motors[1].reverse = 0;
    motors[1].reverse_encoder = 0;
    motors[1].ctrl_gpio_port = CTRL_MOTOR2_GPIO_Port;
    motors[1].ctrl_gpio_pin = CTRL_MOTOR2_Pin;
    motors[1].pwm_timer = MOTOR_PWM_TIM;
    motors[1].pwm_channel = LL_TIM_CHANNEL_CH3;
    motors[1].pwm_tim_autoreload = LL_TIM_GetAutoReload(MOTOR_PWM_TIM);
    motors[1].encoder_timer = MOTOR2_ENC_TIM;
    motors[1].encoder_round_count = 13*4;
    motors[1].torque_coefficient = 0.3f; // A inaccurate approximation
    motors[1].turndown_ratio = 30;
    motors[1].max_velocity = 6*2*3.1415926;
    motors[1].ext_resistor = 1500; // From schematic of this board.
    motors[1].kp_pos = 5;
    motors[1].kd_pos = 0.1;
    motors[1].kp_vel = 5;
    motors[1].ki_vel = 0.1;
    motors[1].kp_torq = 5;
    motors[1].ki_torq = 0.1;

    motors[2].id = 3;
    motors[2].mode = DRV8874_MODE_VELOCITY;
    motors[2].reverse = 0;
    motors[2].reverse_encoder = 0;
    motors[2].ctrl_gpio_port = CTRL_MOTOR3_GPIO_Port;
    motors[2].ctrl_gpio_pin = CTRL_MOTOR3_Pin;
    motors[2].pwm_timer = MOTOR_PWM_TIM;
    motors[2].pwm_channel = LL_TIM_CHANNEL_CH2;
    motors[2].pwm_tim_autoreload = LL_TIM_GetAutoReload(MOTOR_PWM_TIM);
    motors[2].encoder_timer = MOTOR3_ENC_TIM;
    motors[2].encoder_round_count = 13*4;
    motors[2].torque_coefficient = 0.3f; // A inaccurate approximation
    motors[2].turndown_ratio = 30;
    motors[2].max_velocity = 6*2*3.1415926;
    motors[2].ext_resistor = 1500; // From schematic of this board.
    motors[2].kp_pos = 5;
    motors[2].kd_pos = 0.1;
    motors[2].kp_vel = 5;
    motors[2].ki_vel = 0.1;
    motors[2].kp_torq = 5;
    motors[2].ki_torq = 0.1;

    motors[3].id = 4;
    motors[3].mode = DRV8874_MODE_VELOCITY;
    motors[3].reverse = 0;
    motors[3].reverse_encoder = 0;
    motors[3].ctrl_gpio_port = CTRL_MOTOR4_GPIO_Port;
    motors[3].ctrl_gpio_pin = CTRL_MOTOR4_Pin;
    motors[3].pwm_timer = MOTOR_PWM_TIM;
    motors[3].pwm_channel = LL_TIM_CHANNEL_CH4;
    motors[3].pwm_tim_autoreload = LL_TIM_GetAutoReload(MOTOR_PWM_TIM);
    motors[3].encoder_timer = MOTOR4_ENC_TIM;
    motors[3].encoder_round_count = 13*4;
    motors[3].torque_coefficient = 0.3f; // A inaccurate approximation
    motors[3].turndown_ratio = 30;
    motors[3].max_velocity = 6*2*3.1415926;
    motors[3].ext_resistor = 1500; // From schematic of this board.
    motors[3].kp_pos = 5;
    motors[3].kd_pos = 0.1;
    motors[3].kp_vel = 5;
    motors[3].ki_vel = 0.1;
    motors[3].kp_torq = 5;
    motors[3].ki_torq = 0.1;

    for (drv8874_t* motor=motors ; motor<motors+sizeof(motors)/sizeof(motors[0]); motor++)
    {
        DRV8874_LOG_DEBUG("DRV8874 motor %u initialization: reverse=%u, reverse_encoder=%u, round_count=%u, torque_coeffecient=%f, turndown_ratio=%f, max_velocity=%f.\n",
            motor->id,
            motor->reverse,
            motor->reverse_encoder,
            motor->encoder_round_count,
            motor->torque_coefficient,
            motor->turndown_ratio,
            motor->max_velocity);
    }

    err = drv8874_init_adc();
    if(err != DRV8874_OK)
    {
        return err;
    }

    LL_TIM_EnableCounter(MOTOR_PWM_TIM);
    LL_TIM_EnableCounter(MOTOR1_ENC_TIM);
    LL_TIM_EnableCounter(MOTOR2_ENC_TIM);
    LL_LPTIM_StartCounter(MOTOR3_ENC_TIM, LL_LPTIM_OPERATING_MODE_CONTINUOUS);
    LL_LPTIM_StartCounter(MOTOR4_ENC_TIM, LL_LPTIM_OPERATING_MODE_CONTINUOUS);
    LL_TIM_EnableCounter(ENC_TIME_TIM);
    LL_TIM_EnableIT_UPDATE(ENC_TIME_TIM);
    LL_TIM_EnableAllOutputs(MOTOR_PWM_TIM);

    /* Create FreeRTOS timer to handle motor control calculation. */
    motor_torque_control_timer = xTimerCreate("motor_torque_control", pdMS_TO_TICKS(1), pdTRUE, NULL, drv8874_torque_controller);
    motor_velocity_control_timer = xTimerCreate("motor_velocity_control", pdMS_TO_TICKS(2), pdTRUE, NULL, drv8874_velocity_controller);
    motor_position_control_timer = xTimerCreate("motor_position_control", pdMS_TO_TICKS(10), pdTRUE, NULL, drv8874_position_controller);
    xTimerStart(motor_torque_control_timer, 0);
    xTimerStart(motor_velocity_control_timer, 0);
    xTimerStart(motor_position_control_timer, 0);

    /* Create FreeRTOS task to handle motor control calculation. */
    // xTaskCreate(drv8874_controller_task, "motor_control", 1024, NULL, 3, &motor_control_task);

    FreeRTOS_CLIRegisterCommand(&drv8874_control_command_def);
    DRV8874_LOG_INFO("DRV8874 initialization done.\n");
    return DRV8874_OK;
}


drv8874_err_t drv8874_set_position_mode(drv8874_t *dev)
{
    dev->mode = DRV8874_MODE_POSITION;
    DRV8874_LOG_INFO("DRV8874 set motor %u position mode.\n", dev->id);
    return DRV8874_OK;
}
drv8874_err_t drv8874_set_velocity_mode(drv8874_t *dev)
{
    dev->mode = DRV8874_MODE_VELOCITY;
    DRV8874_LOG_INFO("DRV8874 set motor %u velocity mode.\n", dev->id);
    return DRV8874_OK;
}
drv8874_err_t drv8874_set_torque_mode(drv8874_t *dev)
{
    dev->mode = DRV8874_MODE_TORQUE;
    DRV8874_LOG_INFO("DRV8874 set motor %u torque mode.\n", dev->id);
    return DRV8874_OK;
}
drv8874_err_t drv8874_set_position(drv8874_t *dev, drv8874_float_t position)
{
    dev->target_position = position;
    DRV8874_LOG_INFO("DRV8874 set motor %u position: %f rad.\n", dev->id, position);
    return DRV8874_OK;
}
drv8874_err_t drv8874_set_velocity(drv8874_t *dev, drv8874_float_t velocity)
{
    dev->target_velocity = velocity;
    DRV8874_LOG_DEBUG("DRV8874 set motor %u velocity: %f rad/s.\n", dev->id, velocity);
    return DRV8874_OK;
}
drv8874_err_t drv8874_set_torque(drv8874_t *dev, drv8874_float_t torque)
{
    dev->target_torque = torque;
    DRV8874_LOG_INFO("DRV8874 set motor %u torque: %f Nm.\n", dev->id, torque);
    return DRV8874_OK;
}
drv8874_err_t drv8874_set_direction(drv8874_t *dev, drv8874_direction_t direction)
{
    if(direction == DRV8874_DIRECTION_FORWARD)
    {
        LL_GPIO_SetOutputPin(dev->ctrl_gpio_port, dev->ctrl_gpio_pin);
        DRV8874_LOG_TRACE("DRV8874 set motor %u direction forward.\n", dev->id);
    }
    else if(direction == DRV8874_DIRECTION_BACKWARD)
    {
        LL_GPIO_ResetOutputPin(dev->ctrl_gpio_port, dev->ctrl_gpio_pin);
        DRV8874_LOG_TRACE("DRV8874 set motor %u direction backward.\n", dev->id);
    }
    return DRV8874_OK;
}
drv8874_err_t drv8874_start(drv8874_t *dev)
{
    /* Set enable flag */
    dev->enable = 1;

    /* Reset control parameters */
    dev->control_pos = 0;
    dev->error_pos = 0;
    dev->prev_error_pos = 0;
    dev->control_vel = 0;
    dev->error_vel = 0;
    dev->prev_error_vel = 0;
    dev->control_torq = 0;
    dev->error_torq = 0;
    dev->prev_error_torq = 0;
    dev->current_position = 0;
    dev->current_velocity = 0;
    dev->current_torque = 0;
    dev->encoder_count = 0;
    dev->previous_encoder_count = 0;

    LL_TIM_CC_EnableChannel(dev->pwm_timer, dev->pwm_channel);

    return DRV8874_OK;
}
drv8874_err_t drv8874_brake(drv8874_t *dev)
{
    switch (dev->pwm_channel)
    {
    case LL_TIM_CHANNEL_CH1:
        LL_TIM_OC_SetCompareCH1(dev->pwm_timer, 0);
        break;
    case LL_TIM_CHANNEL_CH2:
        LL_TIM_OC_SetCompareCH2(dev->pwm_timer, 0);
        break;
    case LL_TIM_CHANNEL_CH3:
        LL_TIM_OC_SetCompareCH3(dev->pwm_timer, 0);
        break;
    case LL_TIM_CHANNEL_CH4:
        LL_TIM_OC_SetCompareCH4(dev->pwm_timer, 0);
        break;
    default:
        DRV8874_LOG_ERROR("DRV8874 motor %u brake error: unknown pwm channel %d.\n", dev->id, dev->pwm_channel);
        return DRV8874_ERROR;
    }
    return DRV8874_OK;
}
drv8874_err_t drv8874_stop(drv8874_t *dev)
{
    LL_TIM_CC_DisableChannel(dev->pwm_timer, dev->pwm_channel);
    return DRV8874_OK;
}

#ifdef cplusplus
}
#endif